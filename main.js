function getUserPrompt(message) {
	return `You are a professional assistant in classifying, identifying, and prioritizing my emails.
My email addresses are:
  - \`yunjie@dai.sg\`
  - \`kros@dai.sg\`
  - \`xdanger@gmail.com\`
  - \`kros@xd.com\`
  - \`kros@taptap.com\`
  - \`yunjie@taptap.com\`

Now, process the following email:
  <email_headers>
    <date>${message.getDate()}</date>
    <from>${message.getFrom()}</from>
    <to>${message.getTo()}</to>
    <subject>${message.getSubject()}</subject>
  </email_headers>
  <email_plain_body>
    ${message.getPlainBody().slice(0, 200000)}
  </email_plain_body>`;
}

function main() {
	const schema = {
		type: "object",
		properties: {
			summary: {
				type: "string",
				description:
					"Use Simplified Chinese to create a concise list summarizing the email.",
			},
			category: {
				type: "string",
				description:
					"Categorize the email into one of these categories:\n" +
					"  - `Receipts`: Mostly machine-generated documents, such as paper trails, transactional receipts, bank statements (except notification of statements), and so on, should be archived for a long time.\n" +
					"  - `Notices`: This is a machine-generated email to notify me (or my group) of an event or a time-sensitive email that is unimportant or urgent enough for me to pay much attention to, such as social media updates, security alerts, or the results of something. The email is not helpful and is supposed to be deleted after 30/60 days.\n" +
					"  - `Notices/OTP`: This is a subcategory of `Notices`. Especially to verify my email address, containing several digital numbers or combined with short strings. It's time-sensitive. The email is not helpful and should be deleted after I proceed with it.\n" +
					"  - `Notices/Status`: This is a subcategory of `Notices`. Especially to inform me of the status of an online order, shipment and parcel tracking, an App in Google Play / App Store, or a website.\n" +
					"  - `Feeds`: This is a periodical email worth reading, maybe my subscription, such as news, school newsletters, e-magazines, articles, and weekly/monthly reports (except that all contents are machine-generated ones), not including marketing emails for promotion.\n" +
					"  - `Promotions`: This email is a marketing message that may be promotional, bulk, or commercial. It is possible that this email could be classified as spam.\n" +
					"  - `Others`: Any other email you cannot put into the categories above.\n",
				enum: [
					"Receipts",
					"Notices",
					"Notices/OTP",
					"Notices/Status",
					"Feeds",
					"Promotions",
					"Others",
				],
			},
			generated_by: {
				type: "string",
				description:
					"Identify whether the email is generated by a machine, AI, human. Focus on the sender to determine if they are a machine or a human. Emails such as notices, periodical newsletters, transaction receipts, and bank statements should be classified as `machine`. Emails that come from a human but whose wording resembles machine-generated text should be classified as `ai`. Emails that closely mimic natural human tones should be labeled as `human`.",
				enum: ["machine", "ai", "human"],
			},
			time_sensitive: {
				type: "boolean",
				description:
					"The email is urgent and requires immediate notification or response, ideally within one hour.",
			},
			action_required: {
				type: "array",
				// minItems: 0,
				// maxItems: 3,
				description:
					"According to the email content, the email may require further important and essential action(s) other than finishing reading the email from me. Return an empty array if no necessary action is required, DO NOT insert any unnecessary items.",
				items: {
					type: "object",
					properties: {
						action: {
							type: "string",
							description:
								"Use Simplified Chinese to describe the action required in a concise manner.",
						},
						due_date: {
							type: "string",
							// format: "date",
							description:
								"If applicable, set the due date of the action in the format of `YYYY-MM-DD`. If not applicable, set it to `null`.",
						},
					},
					required: ["action"],
					additionalProperties: false,
				},
			},
		},
		required: [
			"summary",
			"category",
			"generated_by",
			"time_sensitive",
			"action_required",
		],
		additionalProperties: false,
	};
	const props = PropertiesService.getScriptProperties();
	let last_processed_timestamp = props.getProperty("LastProcessedMessage_TS");
	if (last_processed_timestamp === null) {
		throw new ReferenceError(
			"`LastProcessedMessage_TS` is not found in ScriptProperties.",
		);
	}
	const threads = GmailApp.getInboxThreads()
		.filter((t) => t.getLastMessageDate().getTime() > last_processed_timestamp)
		.filter(
			(t) =>
				!t.getFirstMessageSubject().includes("failures for Google Apps Script"),
		)
		.sort(
			(t1, t2) =>
				t1.getLastMessageDate().getTime() - t2.getLastMessageDate().getTime(),
		);
	console.log(`[${threads.length}] thread(s) need to be proceed.`);
	for (const t of threads) {
		const last_message_timestamp = t.getLastMessageDate().getTime();
		const last_message = t
			.getMessages()
			.find((m) => m.getDate().getTime() === last_message_timestamp);
		const content = getUserPrompt(last_message);
		const answ = callOpenRouterStructuredOutputs(content, schema);
		// console.log(answ);
		console.log(`${last_message.getSubject()}\n${JSON.stringify(answ)}`);
		// Proceed with different actions by categories
		switch (answ.category) {
			case "Promotions":
				Gmail.Users.Threads.modify(
					{ addLabelIds: ["CATEGORY_PROMOTIONS"] },
					"me",
					t.getId(),
				);
				t.moveToArchive();
				break;
			case "Notices":
			case "Notices/Status":
				Gmail.Users.Threads.modify(
					{ addLabelIds: ["CATEGORY_UPDATES"] },
					"me",
					t.getId(),
				);
				break;
			case "Receipts":
			case "Feeds":
				if (!t.isImportant() && t.isInInbox()) {
					t.moveToArchive();
				}
				break;
			default:
		}
		if (
			[
				"Receipts",
				"Feeds",
				"Notices",
				"Notices/OTP",
				"Notices/Status",
			].includes(answ.category)
		) {
			t.addLabel(GmailApp.getUserLabelByName(answ.category));
		}
		switch (answ.generated_by) {
			case "human":
				t.addLabel(GmailApp.getUserLabelByName("Human"));
				break;
			case "ai":
				t.addLabel(GmailApp.getUserLabelByName("AI"));
				break;
			default:
				t.removeLabel(GmailApp.getUserLabelByName("Human"));
				t.removeLabel(GmailApp.getUserLabelByName("AI"));
		}
		if (answ.action_required.length > 0) {
			t.addLabel(GmailApp.getUserLabelByName("TODO"));
			// answ.action_required.forEach((act) => {
			//   if (act.action && act.action.trim() !== "null") {
			//     createTask(act.action, last_message.getId(), last_message.getSubject(), answ.summary, act.due_date);
			//   }
			// });
		} else {
			t.removeLabel(GmailApp.getUserLabelByName("TODO"));
		}
		if (
			["Notices", "Notices/Status", "Receipts", "Feeds"].includes(
				answ.category,
			) &&
			!answ.action_required
		) {
			t.moveToArchive();
		}
		if (
			answ.time_sensitive ||
			answ.action_required.length ||
			!answ.generated_by === "machine"
		) {
			t.moveToInbox();
		}
		if (
			(answ.time_sensitive || answ.action_required.length) &&
			answ.generated_by !== "machine"
		) {
			t.markImportant();
		}
		last_processed_timestamp = t.getLastMessageDate().getTime();
	}
	props.setProperty("LastProcessedMessage_TS", last_processed_timestamp);
}
